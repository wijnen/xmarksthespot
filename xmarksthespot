#!/usr/bin/env python
# vim: set fileencoding=utf-8 foldmethod=marker :
# xmarksthespot - player for wherigo cartridges.
# Copyright 2012 Bas Wijnen <wijnen@debian.org> {{{
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# }}}

# Imports. {{{
import sys
import os
import gui
import re
import gps
import gtk
import gwc
import time
import wherigo
import Map
import widgets
import gobject
gobject.threads_init ()
try:
	import gst
	have_sound = True
except:
	print ('gst could not be imported: no sound')
	have_sound = False
import argparse
import xmtsconfig
# }}}

# Argument parsing. {{{
a = argparse.ArgumentParser ()
a.add_argument ('cartridge', default = None, nargs = '?', help = 'The cartridge to load', type = str)
a.add_argument ('--debug', help = 'Enable debugging mode', default = False, action = 'store_true')
a.add_argument ('--map', help = 'Map to use as background', type = str, default = None)
args = a.parse_args ()
gwcfile = args.cartridge
class Settings:
	def __init__ (self):
		self.show_start = False
		self.gameobject = None
settings = Settings ()
settings.debug = args.debug
# }}}

def backtrace (): # {{{
	sys.stderr.write ('=' * 78 + '\n')
	try:
		d = 0
		while True:
			frame = sys._getframe (d)
			sys.stderr.write ('\t%s:%d %s\n' % (frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name))
			d += 1
	except ValueError:
		pass
	sys.stderr.write ('=' * 78 + '\n')
# }}}

class Position: # {{{
	def __init__ (self, lat = None, epx = None, lon = None, epy = None, alt = None, epv = None, speed = None, eps = None, climb = None, epc = None, track = None, epd = None, time = None, ept = None):
		self.lat = lat
		self.epx = epx
		self.lon = lon
		self.epy = epy
		self.alt = alt
		self.epv = epv
		self.speed = speed
		self.eps = eps
		self.climb = climb
		self.epc = epc
		self.track = track
		self.epd = epd
		self.time = time
		self.ept = ept
	def __nonzero__ (self):
		return self.time is not None
	def __str__ (self):
		if self.time == None:
			return 'None'
		return 'lat:%f±%f lon:%f±%f alt:%f±%f speed:%f±%f climb:%f±%f track:%f±%f time:%s±%f' % (self.lat, self.epx, self.lon, self.epy, self.alt, self.epv, self.speed, self.eps, self.climb, self.epc, self.track, self.epd, self.time, self.ept)
# }}}

class GpsPoller: # {{{
	def __init__(self):
		self.current_value = Position ()
		self.idle = [10, None]
		self.session = None
	def get_pos (self):
		#print 'getting pos', self.session
		if self.session is None:
			try:
				#print 'new session'
				self.session = gps.gps (mode = gps.WATCH_ENABLE)
			except:
				#print 'no gps:', sys.exc_value
				self.session = None
				return Position ()
		try:
			while self.session.waiting ():
				value = self.session.next ()
				#print value
				# Save only position, not every event.
				if value['class'] == 'DEVICE' and value['activated'] == 0:
					self.current_value = Position ()
					continue
				if value['class'] != 'TPV':
					continue
				if value['mode'] < 2 or not all ([x in value for x in ('lat', 'lon', 'epx', 'epy')]):
					self.current_value = Position ()
				else:
					self.current_value = Position (*[value[x] if x in value else None for x in ('lat', 'epx', 'lon', 'epy', 'alt', 'epv', 'speed', 'eps', 'climb', 'epc', 'track', 'epd', 'time', 'ept')])
		except:
			#print 'gps exception:', sys.exc_value
			self.current_value = Position ()
		#print self.current_value
		ret = self.current_value
		if self.idle[1] == ret.time:
			if self.idle[0] == 10:
				self.idle = [0, None]
				ret = Position ()
				self.current_value = ret
				self.session = None
			else:
				self.idle[0] += 1
		else:
			self.idle = [0, ret.time]
		return ret
# }}}

def make_str (degs, plus, minus): # {{{
	'Make a string value from a float degree value'
	sign = plus if degs > 0 else minus
	degs = abs (degs)
	deg = int (degs)
	degs -= deg
	degs *= 60
	min = int (degs)
	degs -= min
	degs *= 60
	sec = degs
	return '''%d°%d'%.2f"%s''' % (deg, min, sec, sign)
# }}}

class CB: # {{{
	pipeline = None
	def dialog (self, table):
		global queue
		self.update ()
		queue_reset ()
		for m in table.list ():
			queue += (m,)
		next_message ()
		self.update ()
	def message (self, table):
		global queue
		self.update ()
		queue_reset ()
		queue += (table,)
		next_message ()
		self.update ()
	def get_input (self, zinput):
		global queue
		self.update ()
		queue_reset ()
		queue += (zinput,)
		next_message ()
		self.update ()
	def play (self, media):
		self.stop_sound ()	# includes update.
		if not hasattr (media, '_sound'):
			return
		if have_sound:
			try:
				CB.pipeline = gst.Pipeline ("pipeline")
				CB.source = gst.element_factory_make ("appsrc", "source")
				CB.pipeline.add (CB.source)
				CB.decoder = gst.element_factory_make ("decodebin", "decoder")
				CB.pipeline.add (CB.decoder)
				CB.converter = gst.element_factory_make ("audioconvert", "converter")
				CB.pipeline.add (CB.converter)
				CB.sink = gst.element_factory_make ("alsasink", "sink")
				CB.pipeline.add (CB.sink)
				CB.source.link (CB.decoder)
				CB.decoder.connect ('new-decoded-pad', self.new_pad)
				CB.converter.link (CB.sink)
				CB.pipeline.set_state (gst.STATE_PAUSED)
				CB.source.emit ('push-buffer', gst.Buffer (media._sound))
			except:
				# Emit error message?
				print ('playing sound failed: %s' % sys.exc_value)
				pass
	def new_pad (self, dbin, pad, is_last):
		try:
			CB.decoder.link (CB.converter)
			CB.pipeline.set_state (gst.STATE_PLAYING)
		except:
			pass
	def stop_sound (self):
		self.update ()
		if have_sound:
			try:
				if CB.pipeline:
					CB.pipeline.set_state (gst.STATE_NULL)
					CB.pipeline = None
					CB.source = None
					CB.decoder = None
					CB.converter = None
					CB.sink = None
			except:
				pass
	def set_status (self, text):
		self.update ()
		g.statusbar = text
	def save (self):
		self.update ()
		save_cartridge (None) # TODO: filename?
	def quit (self):
		self.update ()
		print ('request to quit')
		#gtk.main_quit ()
	def drive_to (self, *a):
		self.update ()
		print ("I'm supposed to drive to", a)
		# TODO
	def alert (self):
		self.update ()
		print 'alert!'
		# Note: this doesn't do anything (on machines without a pc speaker? TODO)
		gtk.gdk.beep ()
	def log (self, level, levelname, text):
		self.update ()
		if level >= minloglevel:
			logline = '%s|%f|%f|%f|%f|%s: %s' % (time.strftime ('%Y%m%d%H%M%S', time.gmtime ()), wherigo.Player.ObjectLocation.Latitude, wherigo.Player.ObjectLocation.Longitude, wherigo.Player.ObjectLocation.Altitude, wherigo.Player.Precision, levelname, text)
			print (logline)
			log.add_log (level, levelname, text)
	def show (self, screen, item):
		# 'Detail', 'Inventory', 'Item', 'Location', 'Main', 'Tasks'
		self.update ()
		if screen == wherigo.DETAILSCREEN:
			if isinstance (item, wherigo.Zone):
				g.focus_location = True
				g.select_location = item
			elif isinstance (item, (wherigo.ZItem, wherigo.ZCharacter)):
				if item.Container == wherigo.Player:
					g.focus_inventory = True
					g.select_inventory = item
				else:
					g.focus_environment = True
					g.select_environment = item
			elif isinstance (item, wherigo.ZTask):
				g.focus_task = True
				g.select_task = item
			else:
				raise AssertionError ('Invalid type to show details for')
		elif screen == wherigo.INVENTORYSCREEN:
			g.focus_inventory = True
		elif screen == wherigo.ITEMSCREEN:
			g.focus_environment = True
		elif screen == wherigo.LOCATIONSCREEN:
			g.focus_location = True
		elif screen == wherigo.MAINSCREEN:
			pass
		elif screen == wherigo.TASKSCREEN:
			g.focus_task = True
		else:
			raise AssertionError ('Invalid screen to show')
	def update (self):
		g.update_location = True
		g.update_inventory = True
		g.update_environment = True
		g.update_task = True
		if settings.debug:
			g.update_timer = True
	def update_stats (self):
		#locationscreen.update_stats ()
		#environmentscreen.update_stats ()
		pass
	def update_map (self):
		#locationscreen.update_map ()
		#environmentscreen.update_map ()
		pass
	def add_timer (self, time, cb):
		if time > 0:
			return gobject.timeout_add (int (time * 1000), cb)
		else:
			return gobject.idle_add (cb)
	def remove_timer (self, handle):
		gobject.source_remove (handle)
# }}}

def next_message (widget = None, name = None, item = None, source = None): # {{{
	global queue, current_msg, current_data, restore_page
	# current_msg is the current message object
	m = current_msg
	if len (queue) != 0:
		current_msg = queue.pop (0)
	else:
		current_msg = None
	next_current = current_msg
	if m is not None:
		# Fire event for previous message
		if isinstance (m, wherigo.ZInput):
			# No arguments.
			assert name is None
			if m.InputType == 'MultipleChoice':
				g.history_add = (current_data[0], current_data[1], current_data[2], item)
				if m.OnGetInput:
					print 'OnGetInput multiple choice %s' % m.Name
					m.OnGetInput (m, item)
					cbs.update ()
				else:
					print 'no callback for multiple choice input'
			elif m.InputType == 'Text':
				assert item is None
				item = widget.get_text () if widget else None
				g.history_add = (current_data[0], current_data[1], current_data[2], item)
				if m.OnGetInput:
					print 'OnGetInput text %s' % m.Name
					m.OnGetInput (m, item)
					cbs.update ()
				else:
					print 'no callback for text input'
			else:
				raise AssertionError ('unknown input type')
		else:
			# Argument is passed to button callback.
			if item is None:
				item = name
			g.history_add = (current_data[0], current_data[1], current_data[2], item)
			if 'Callback' in m:
				# for Ok buttons, name is used; for choices, item is used. Allow both.
				#print 'Callback'
				m['Callback'] (item)
				cbs.update ()
			else:
				#print 'not running Callback for %s' % m['Name']
				pass
	if current_msg is None:
		if restore_page:
			restore_page ()
		g.message_show = False
		return
	if next_current is not current_msg:
		# The queue changed since this was set; don't interfere.
		return
	if isinstance (current_msg, wherigo.ZInput):
		if hasattr (current_msg, 'Media'):
			media = current_msg.Media
		else:
			media = None
		text = current_msg.Text
		if current_msg.InputType == 'MultipleChoice':
			# (commandname, pre-text, other-text, ((text, target), ...), source
			buttons = [(None, None, None, [(x, x) for x in current_msg.Choices.list ()], None)]
		elif current_msg.InputType == 'Text':
			buttons = [None]
		else:
			raise AssertionError ('unknown input type')
	else:
		if 'Media' in current_msg:
			media = current_msg['Media']
		else:
			media = None
		text = current_msg['Text']
		# (commandname, pre-text, other-text, ((text, target), ...), source
		if 'Buttons' in current_msg:
			b = current_msg['Buttons'].list ()
			buttons = [(None, None, None, [(b[t], 'Button%d' % (t + 1)) for t in range (len (b))], None)]
		else:
			buttons = [(None, None, None, [('Ok', 'Button1')], None)]
	if not g.message_show:
		restore_page = g.save_page
	text = re.sub ('<br\s*/?>', '', text, flags = re.I)
	text = re.sub ('&nbsp;', ' ', text, flags = re.I)
	text = re.sub ('&lt;', '<', text, flags = re.I)
	text = re.sub ('&gt;', '>', text, flags = re.I)
	text = re.sub ('&amp;', '&', text, flags = re.I)
	current_data = (media, text, buttons)
	g.message_set = (current_data[0], current_data[1], current_data[2], next_message)
	g.focus_message = True
# }}}

def queue_reset (): # {{{
	global queue
	queue = []
# }}}

# GUI actions. {{{
def file_new (widget): # {{{
	settings.gameobject = None
	wherigo.ZCartridge._new ()
	g.message_show = False
	cbs.update ()
# }}}

def file_open (widget): # {{{
	g.show_opendialog = True
# }}}

def file_save (widget): # {{{
	g.show_savedialog = True
# }}}

def file_quit (widget): # {{{
	gtk.main_quit ()
# }}}

def help_about (widget): # {{{
	aboutdialog.show ()
# }}}

def open_cb (response): # {{{
	if response != 0:
		open_cartridge (g.open_filename)
	g.show_opendialog = False
	return True
# }}}

def save_cb (response): # {{{
	if response != 0:
		save_cartridge (g.save_filename)
	g.show_savedialog = False
	return True
# }}}

def open_cartridge (cartfile): # {{{
	def start_game (widget, name, item, source): # {{{
		g.message_show = False
		startlayer.markers = []
		# Player location MUST be valid at this point.
		# If the GPS hasn't had a signal yet, assume the startinglocation as current player location.
		# If that is not valid, use zero.
		if wherigo.Player.ObjectLocation == wherigo.INVALID_ZONEPOINT:
			wherigo.Player.ObjectLocation = settings.gameobject.StartingLocation
			if wherigo.Player.ObjectLocation == wherigo.INVALID_ZONEPOINT:
				wherigo.Player.ObjectLocation = wherigo.ZonePoint (0, 0, 0)
		if settings.gameobject.OnStart:
			print 'OnStart'
			settings.gameobject.OnStart (settings.gameobject)
		cbs.update ()
	# }}}
	file_new (None)
	# Set up config. {{{
	config = {}
	try:
		name = os.getlogin ().capitalize ()
	except:
		# We're on Windows, or something else is wrong.
		# Don't bother, just use a default.
		name = 'Monty Python'
	for key, default in (('Id', 0), ('URL', 'about:blank'), ('Device', 'PocketPC'), ('PlayerName', name), ('CompletionCode', 'completion-code'), ('env_Platform', 'xmarksthespot'), ('env_CartFolder', '/whatever'), ('env_SyncFolder', '/whatever'), ('env_LogFolder', '/whatever'), ('env_PathSep', '/'), ('env_DeviceID', 'Python'), ('env_Version', '2.11-compatible'), ('env_Downloaded', '0'), ('env_CartFilename', cartfile), ('env_Device', None)):
		env = os.getenv ('XMTS_' + key.upper ())
		if env is not None:
			config[key] = env
		elif hasattr (g, 'config_' + key):
			config[key] = getattr (g, 'config_' + key)
		else:
			config[key] = default
	if config['env_Device'] is None:
		config['env_Device'] = config['Device']
	# }}}
	settings.gameobject = wherigo._load (cartfile, cbs, config)
	# Replace image data with their pixbuf. {{{
	for i in settings.gameobject._getmedia ():
		if not hasattr (i, '_image'):
			# Sound media file.
			continue
		px = gtk.gdk.PixbufLoader ()
		px.write (i._image)
		px.close ()
		i._image = px.get_pixbuf ()
	# }}}
	# Set up start message. {{{
	text = 'You are about to play "%s"' % settings.gameobject.Name
	if settings.gameobject.Description.strip () != '':
		text += ':\n\n' + settings.gameobject.Description
	else:
		text += '.'
	text += '\n\nPlease go to the starting point and press ok.\n'
	if settings.gameobject.StartingLocationDescription.strip () != '':
		text += 'The starting point for this cartridge is defined as follows:\n\n' + settings.gameobject.StartingLocationDescription
	# (commandname, pre-text, other-text, ((text, target), ...), source
	buttons = [(None, None, None, (('Ok', None),), None)]
	g.history_add = (settings.gameobject.Media, text, buttons, None)
	g.message_set = (settings.gameobject.Media, text, buttons, start_game)
	g.focus_message = True
	if settings.gameobject.StartingLocation:
		startlayer.markers = [[(settings.gameobject.StartingLocation.latitude, settings.gameobject.StartingLocation.longitude), (True, True)]]
	# }}}
	cbs.update ()
# }}}

def save_cartridge (cartfile): # {{{
	if settings.gameobject.OnSync:
		print 'OnSync'
		settings.gameobject.OnSync ()
	# TODO.
# }}}

def command (object, name, item = None): # {{{
	cb = 'On' + name
	if hasattr (object, cb):
		getattr (object, cb) (object, item)
		cbs.update ()
	else:
		print ("Callback %s:%s not called, because it doesn't exist" % (object.Name, cb))
# }}}

def skip_one (): # {{{
	global skipped_time
	skipped_time += g.skip_time
	update ()
	settings.gameobject._reschedule_timers ()
# }}}

def skip_more (): # {{{
	global skipped_time
	while current_msg is None:
		extra_time = g.skip_time
		if extra_time == 0:
			break
		skipped_time += extra_time
		update ()
		settings.gameobject._reschedule_timers ()
		while gtk.events_pending ():
			gtk.main_iteration (False)
# }}}
# }}}

# Initialize globals. {{{
restore_page = None
skipped_time = 0
queue = []
current_msg = None
current_data  = None
wherigo._script = None
cbs = CB ()
# }}}

# Schedule periodic updates. {{{
device = GpsPoller ()
def update ():
	fp = settings.map.get_force_position ()
	if fp is not None:
		p = Position (fp[0], None, fp[1], None, wherigo.Player.ObjectLocation.altitude () if wherigo.Player and wherigo.Player.ObjectLocation else 0, None, 0, None, 0, 0, 0, 0, 0, 0)
		g.position_locked = True
	elif not g.position_locked:
		p = device.get_pos ()
	else:
		p = None
	if settings.gameobject:
		update_all = settings.gameobject._update (p, skipped_time + time.time ())
		inside = wherigo.Player.InsideOfZones.list ()
	else:
		update_all = False
		inside = []
	if p:
		g.lat_label = make_str (p.lat if p.lat else 0, 'N', 'S')
		g.lon_label = make_str (p.lon if p.lon else 0, 'E', 'W')
		g.alt_label = '%d m' % (p.alt if p.alt else 0)
		position.markers[0] = [(p.lat, p.lon, p.epy, p.epx), [True, True]]
	else:
		position.markers[0][1][1] = False
	if update_all or settings.debug:
		cbs.update ()
	cbs.update_stats ()
	settings.map.update ()
	if len (inside) == 0:
		instr = 'You are not in a zone'
	elif len (inside) == 1:
		instr = "You are in the zone '%s'" % inside[0].Name
	else:
		instr = 'You are in the zones ' + ', '.join (["'%s'" % i.Name for i in inside[:-1]]) + " and '" + inside[-1].Name + "'"
	g.inside_label = instr
	return True
gtk.timeout_add (1000, update)
# }}}

# Set up map. {{{
settings.map = Map.Map (47.1, -88.5)
settings.map.set_zoom (100000)	# pixels per degree. 1 degree is about 100 km.
settings.map.grab_focus ()
# }}}
g = gui.Gui (	# {{{
		events = {
			'command': command,
			'file_open_response': open_cb,
			'file_save_response': save_cb,
			'file_new': file_new,
			'file_open': file_open,
			'file_save': file_save,
			'file_quit': file_quit,
			'help_about': help_about,
			'skip_one': skip_one,
			'skip_more': skip_more,
			},
		inputs = (
			'taskcolor', 'historycolor', 'inventorycolor', 'locationcolor',
			'charactercolor', 'objectcolor', 'messagecolor', 'logcolor',
			'positioncolor', 'gridcolor', 'startcolor', 'customcolor',
			'open_filename', 'save_filename',
			'save_page', 'skip_time',
			'position_locked',
		),
		outputs = (
			'show_opendialog', 'show_savedialog',
			'show_debug', 'update_timer',
			'focus_location', 'select_location', 'update_location',
			'focus_inventory', 'select_inventory', 'update_inventory',
			'focus_environment', 'select_environment', 'update_environment',
			'focus_tasks', 'select_tasks', 'update_task',
			'message_show', 'message_set', 'focus_message',
			'history_add',
			'lat_label', 'lon_label', 'alt_label', 'inside_label',
			'statusbar'
		),
		widgets = widgets.widgets,
		gtk = {'map': settings.map},
		data = settings)
if settings.debug:
	g.show_debug = True
# }}}
# Add map layers. {{{
if args.map is not None:
	settings.map.add_layer (Map.MapLayer (settings.map, args.map))
settings.map.add_layer (Map.GridLayer (settings.map, g.gridcolor))
position = Map.PositionLayer (settings.map, g.positioncolor)
position.markers = [[(0, 0, None, None), [False, True]]]
settings.map.add_layer (position)
startlayer = Map.MarkerLayer (settings.map, g.startcolor)
settings.map.add_layer (startlayer)
customlayer = Map.MarkerLayer (settings.map, g.customcolor)
settings.map.add_layer (customlayer)
# }}}
file_new (None)
if gwcfile:
	open_cartridge (gwcfile)
g ()
