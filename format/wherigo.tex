\documentclass{article}
\usepackage{listings}
\usepackage{hyperref}
\renewcommand\arraystretch{2}
\begin{document}

\textbf{\Large Specification of Wherigo 2.0}

\tableofcontents

\section{Introduction}
This document aims to be the authorative reference for all technical things
about Wherigo version 2.0. It is a work in progress. If you have any
suggestions for changes or additions, please send them to me at
wijnen@debian.org.

This document only specifies what the Cartridge writer can see. An Engine MAY
do extra processing and give extra feedback to the Player, but it MUST NOT do
this in a way that can be detected by the Cartridge. Any requirements and
prohibitions in this document are meant in this context.

This document intends to define all requirements and features for Cartridges.
These requirements MUST be respected by Authors (including Builders) and
Engines.


\section{History of Wherigo}
Originally, Wherigo was released as a closed source Engine with a closed source
Builder. There was no documentation about the internal format.

The Wherigo foundation was started by a group of people who want to improve the
platform.  This includes better documentation, so Authors can write better
Cartridges.  The purpose of this document is to be the authorative source for
any information about the file formats.

The format described here is based on the original Wherigo format, but it is
not identical.


\section{Definitions}
Throughout this document, the following definitions are used:

\begin{enumerate}
	\item Player: the person playing the Wherigo game.
	\item Author: the person designing the Cartridge.
	\item Engine: the program used to play the game. This program does not contain information about the game itself; it needs a Cartridge to be used.
	\item Editor: the program used to create a Cartridge. This is usually a program designed for creating Wherigo cartridges, but can also be a simple text editor.
	\item Builder: an Editor with features intended to make Cartridge creation easier.
	\item Compiler: the program used to convert Cartridge source into  a file intended for playing.
	\item Cartridge: a game definition, which is processed by an Engine to present a game to the Player.  Cartridges can be in source or compiled form.
	\item Game Object: The ZCartridge object which holds information about the cartridge that is being played.
	\item Event: a function in the Lua code which is called by the Engine in response to an event, such as the Player pressing a button. If the function is not defined, triggering the Event is not an error.
	\item Web Site: a central place to download Cartridges and mark them as completed.
	\item MAY: an option.
	\item MUST: a requirement.
	\item MUST NOT: a prohibition.
	\item SHOULD: a requirement in most cases, but there may be circumstances in which it is better to follow a different course.
	\item SHOULD NOT: a prohibition in most cases, but there may be circumstances in which it is better to follow a different course.
	\item Authoring Time: when the cartridge is written by the Author.
	\item Compile Time: when a cartridge is compiled by a Compiler.
	\item Boot Time: When the cartridge is started, until the UI is presented to the Player.
	\item Run Time: the main phase of the game.
	\item Table: a Lua table.
\end{enumerate}

\section{Cartridge startup}
When playing a Wherigo game, the Player starts the Engine and loads a
Cartridge. The Engine MUST then perform at least the following actions, in this
order:

\begin{enumerate}
\item Create a clean Lua 5.1 environment.
\item Remove \verb-debug-, \verb-loadfile-, \verb-dofile-,
	\verb-package.loadlib- and \verb-io-, and everything from \verb-os-,
	except \verb-os.clock-, \verb-os.date-, \verb-os.difftime-,
	\verb-os.setlocale- and \verb-os.time-.
\item Add the ``Wherigo'' module, described below, to the environment.
\item Create all the objects referenced in and from Cartridge.wfi, described below.
\item Run the Lua code from \verb-Cartridge.lua-. This code is running during Boot Time.
\item Wait for a GPS fix and update Player.ObjectLocation and Player.PositionAccuracy.
\item Trigger the OnStart Event. This and everything after it is running during Run Time.
\end{enumerate}

When a saved game is restored, the same procedure must be used, except that
OnStart is not triggered.  Instead, the Engine MUST first restore all saved
variables from the save file, and then trigger OnRestore.

During Boot Time, the player location is not defined and the interface
functions are not working yet.  The Cartridge MUST NOT use them.

\section{The Lua operating environment.}

The Cartridge code runs in a clean Lua 5.1 environment (with ``dangerous''
functions removed). Everything that is specific to Wherigo is in the Wherigo
module. Below is a description of all its contents. Engines MAY include more
members inside the Wherigo module for internal use. Anything that is not
defined in this document MUST NOT be used by Authors or Builders. This includes
creating new objects, because they may interfere with the Engine's internals.
Engines MUST NOT create or modify any variable outside of the Wherigo module.
In other words: the Wherigo module is owned by the Engine, the rest is owned by
the Author.

All constructors (functions which are used to create a new object) for objects
implementing the ZObject interface can be called in two ways: either with the
Game Object as the only argument, or with a Table as the only argument. The
keys in the Table are initial values for the attributes of the object that is
constructed.  It MUST have a key named \verb-cartridge-, which has the Game
Object as its value.

Unless otherwise noted, all functions are methods. This includes event
functions, which need to be defined by the Cartridge.  This means they need to
get the object they are called on as a first argument. The normal way to do
this in Lua is by calling it as \verb-object:function()- instead of
\verb-object.function()-.

\newcommand\codedef[2]{\par\noindent\begin{tabular}{|l|l|}\hline\parbox{.4\textwidth}{#1}&\parbox{.5\textwidth}{#2}\\\hline\end{tabular}\par}
\newcommand\funcdef[4]{
	\par\vskip.5\baselineskip
	\par\noindent\textbf{Function:} #1 $\rightarrow$ #2\par
	\noindent\textbf{Arguments:} \parbox{.8\textwidth}{#3}\par
	\noindent\textbf{Description:} \parbox{.8\textwidth}{#4}\par
	\vskip.5\baselineskip
}
\newcommand\attrdef[3]{
	\par\vskip.5\baselineskip
	\par\noindent\textbf{Attribute:} #1 (#2)\par
	\noindent\textbf{Description:} \parbox{.8\textwidth}{#3}\par
	\vskip.5\baselineskip
}
\subsection{Constants}
\codedef{INVALID\_ZONEPOINT}{An object, used instead of a ZonePoint, to indicate a ``no coordinate''-value.}
\codedef{DETAILSCREEN\\INVENTORYSCREEN\\ITEMSCREEN\\LOCATIONSCREEN\\MAINSCREEN\\TASKSCREEN}{These constants are used with ShowScreen to focus the Player's attention to a certain part of the Engine's interface.}
\codedef{LOGDEBUG\\LOGCARTRIDGE\\LOGINFO\\LOGWARNING\\LOGERROR}{These constants are used with LogMessage, to set the type of message to log.}

\subsection{Player object}
The Player object is a ZItem which is tied to the Player. Its position is
automatically set to the device's GPS coordinates, and when the Player moves,
certain events may be triggered: OnEnter, OnLeave, OnProximity, OnDistant. The
Player object is also handled specially by some functions. This is described in
each function where this is the case.  Because the Player object is created
before the Game Object, its \verb-Cartridge- attribute is not set to the Game
Object, but to \verb-nil-.

Player.Name is set to the Player name, as defined by the Cartridge metadata.
Player.CompletionCode is set to a special code from the metadata, which can be
used to mark the Cartridge as ``Completed'' on the Web Site.

Player.PositionAccuracy is the accuracy of the GPS signal, in meters.  It is automatically updated.  If the hardware gives separate values for different dimensions, the conversion to this value is implementation defined.

Player.ObjectLocation is initially set to \verb-INVALID_ZONEPOINT-.  Any code
which depends on the Player location MUST NOT be run at Boot Time.  At Run
Time, the coordinates MUST always be valid.

Player.InsideOfZones is a Table of Zones that the Player is inside of.  The Engine MUST automatically update it.

\subsection{Interfaces}
Most objects which are used by Wherigo provide an interface, depending on their
function.  Many objects provide the ZObject interface in addition to their own
more specialized interface.  Objects can be created by calling the interface's
constructor function.  This will return a new object.

All constructors start with a capital letter. In these descriptions, member
functions are shown with a hypothetical object with the interface name, but in
all lowercase letters. Argument values in square brackets are optional. Their
default values are given in the explanation.

All constructors for objects which provide the ZObject interface take either a
ZCartridge as their first argument, or a Table with a Cartridge key in it and
optionally more keys. This is not explained every time. The cartridge argument
must always be the Game Object.

Interfaces which have an other interface name in parentheses after their own
name provide this interface in addition to the described attributes and
methods.  Documentation for those implicit members is not repeated.

\subsubsection{ZObject}
Interface for all objects. This should never be constructed directly, but only
as part of an interface which provides this interface.
\funcdef{zobject:Contains (object)}{boolean}{object: ZObject which is tested for being inside this one.}{Return true if zobject is the Container of object, or if zobject:Contains (object.Container). As a special case, if zobject is a Zone and object is Player, return IsPointInZone (Player.ObjectLocation, zobject)}
\funcdef{ZObject.made (object)}{boolean}{object: the object to be tested}{Tests whether an object is made by this constructor. It will also return true if the tested object is made by a constructor which provides the calling interface. This is not a member, it does not take a self object as first argument, and must not be called with `:'.}
\funcdef{zobject:MoveTo (container)}{nil}{container: new owner of zobject, or nil}{Remove zobject from its current container, and optionally into a new one. All Container and Inventory properties are changed accordingly.}
\attrdef{Active}{Boolean}{Non-active objects are ignored for all events, and are not shown in any UI elements.}
\attrdef{Cartridge}{ZCartridge}{The Game Object.}
\attrdef{Commands}{Table of ZCommand}{Commands which may be available with this object. Only valid for ZItem and Zone.}
\attrdef{Container}{ZObject}{ZObject that contains this object. Always a Zone, ZItem, or nil. This attribute is read-only; it is updated automatically when using MoveTo.}
\attrdef{CurrentBearing}{number}{Direction from the Player to this object. This is automatically updated by the Engine. 0 if the Player contains this object.}
\attrdef{CurrentDistance}{Distance}{Distance from the Player to this object. This is automatically updated by the Engine. 0 if the Player contains this object.}
\attrdef{Description}{String}{Description of this ZObject. For objects which can appear in the UI, this is shown as their details.}
\attrdef{Icon}{ZMedia}{Image which represents this ZObject. This can be used as an icon when the object is shown in a list.}
\attrdef{Inventory}{Table of ZObject}{A list of all objects which have this ZObject set as their Container. This attribute is read-only; it is updated automatically when using MoveTo. For Zones, the Player object is automatically added or removed when the player enters or leaves the zone, respectively. This happens before OnEnter or OnExit are triggered.}
\attrdef{Media}{ZMedia}{Image which represents this ZObject. This can be used when a larger image is required, usually for the object's details.}
\attrdef{Name}{String}{Name of this object. Used when presenting this object in the UI.}
\attrdef{On\textit{CommandName}}{Function}{These event callbacks are available for ZItem and Zone objects, once for each ZCommand that is available for it. \textit{CommandName} is the key of the command in the Commands Table. It is triggered by selecting the command. See ZCommand for details.}
\attrdef{Visible}{Boolean}{This ZObject is not shown in the UI unless this is set. It does respond normally to events though (if not also inactive).}

\subsubsection{ZCartridge (ZObject)}
The interface for the Game Object. There is always exactly one object
constructed with this interface. It is initialized with the metadata from the
Cartridge, and holds some tables which can be used to reach objects in the
game. It does not have a constructor; it MUST be defined in Cartridge.wfi.
\funcdef{zcartridge:GetAllOfType (String)}{Table of ZObjects}{String: type name to search for}{Return all items in zcartridge.AllZObjects of the requested type. Possible types are ZCartridge, ZItem, Zone, ZMedia, ZTask, ZTimer, and ZInput.}
\funcdef{zcartridge:RequestSync ()}{nil}{}{Save the current state of the Game. More information on saving is below.}
\attrdef{AllZObjects}{Table of ZObject}{List of all ZObjects in this Cartridge (including the Game Object itself). This attribut is read-only. It is automatically updated when ZObjects are created or destroyed.}
\attrdef{Activity}{String}{Activity from the metadata.}
\attrdef{Author}{String}{Version from the metadata.}
\attrdef{BuilderVersion}{String}{BuilderVersion from the metadata.}
\attrdef{Company}{String}{Company from the metadata.}
\attrdef{CreateDate}{String}{CreateDate from the metadata.}
\attrdef{Copyright}{String}{Copyright claim from the metadata.}
\attrdef{LastPlayedDate}{String}{LastPlayedDate from the metadata.}
\attrdef{License}{String}{License from the metadata. Only the short part; the Long Value is not included.}
\attrdef{Media}{ZMedia}{Poster from the metadata.}
\attrdef{OnEnd}{Function}{Event, called when the game ends.}%XXX: Why?  It's not like anything can still be done...  Also, this seems like a fake event.
\attrdef{OnRestore}{Function}{Event, called immediately after loading a saved game. See more on saving below.}
\attrdef{OnStart}{Function}{Event, called when the game is started.}
\attrdef{OnSync}{Function}{Event, called just before saving a game. See more on saving below.}
\attrdef{PublishDate}{String}{PublishDate from the metadata.}
\attrdef{StartingLocation}{ZonePoint}{StartingLocation from the metadata.}
\attrdef{StartingLocationDescription}{String}{StartingLocationDescription from the metadata.}
\attrdef{TargetDevice}{ZMedia}{TargetDevice from the metadata.}
\attrdef{TargetDeviceVersion}{String}{TargetDeviceVersion from the metadata.}
\attrdef{UpdateDate}{String}{UpdateDate from the metadata.}
\attrdef{Version}{String}{Version from the metadata.}
\attrdef{ZVariables}{Table of strings or numbers}{See information on saving below.}

\subsubsection{ZItem (ZObject)}
An entity in the game, which can be interacted with. These can often be picked up, or talked to.  If ObjectLocation is nil, their location is identical to that of their Container.  If they do not have a Container, or its ObjectLocation is also nil, they MUST NOT be shown at any location, and CurrentBearing and CurrentDistance MUST both be set to infinity.
\funcdef{ZItem (Cartridge)}{ZItem}{-}{Constructor.}
\attrdef{ObjectLocation}{ZonePoint}{Current location of this ZObject.}

\subsubsection{ZonePoint}
Position on the globe.  Latitude and Longitude are defined in degrees.
Altitude is defined in meters.
\funcdef{ZonePoint (latitude, longitude, altitude)}{ZonePoint}{Coordinates.}{Constructor.}
\attrdef{altitude}{number}{Altitude.}
\attrdef{latitude}{number}{Latitude.}
\attrdef{longitude}{number}{Longitude.}

\subsubsection{Zone (ZObject)}
A region on the globe. The region is defined by its perimiter.  Every closed
curve divides a sphere into two parts. One part is inside and the other is
outside. The inside part is the smaller of the two parts.

Zones with no surface are allowed, including single points.

If the Player's coordinate changes in a big step, for whatever reason, all
callbacks that should have been called if it had changed in small steps must be
called. For example, if a Zone has a positive ProximityRange and DistanceRange,
the current state is NotInRange and the Player is found to be inside it,
OnDistant, OnProximity and OnEnter must all be called (in that order)
immediately.

For very thin Zones, it is possible that the Player's location skips from one
side of it to the other without registering a position inside the Zone.  When
that happens, the Engine MAY trigger the events for entering and leaving the
Zone.

When the Engine considers the Player to be inside a Zone is implementation
defined.  However, it MUST be possible to trigger the OnEnter event of a single
point Zone.

The Zone perimiter is defined by a series of points.  The edge of the Zone is
the union of all line segments between two consecutive points in the sequence.
The Zone MUST NOT contain intersecting segments.  The last point is implicitly
connected to the first point.

\funcdef{Zone (Cartridge)}{Zone}{-}{Constructor.}
\attrdef{OnDistant}{Function}{Event, triggered when the Player enters the \textit{Distant} ring of a Zone. Note that this can be entered from Proximity and from NotInRange, and if Proximity is set to a nonpositive value, also from Inside.}
\attrdef{OnEnter}{Function}{Event, triggered when the Player enters the Zone.}
\attrdef{OnExit}{Function}{Event, triggered when the Player leaves the Zone.}
\attrdef{OnProximity}{Function}{Event, triggered when the Player enters the \textit{Proximity} ring of a Zone. Note that this can be entered from Inside and from Distant, and if DistanceRange is set to a value which is not larger than ProximityRange, from NotInRange.}
\attrdef{Points}{Table of ZonePoint}{Perimiter of the zone.}
\attrdef{ShowObjects}{String}{One of \texttt{OnEnter}, \texttt{OnProximity}, or \texttt{Always}.  Defines when ZObjects which are inside the Zone are visible. When the Player is inside the Zone, they are always visible. When the Player is in the proximity range, they are only visible if this is set to Always or OnProximity. Otherwise they are only visible if this is set to Always.}
\attrdef{State}{String}{State of the Player with respect to this Zone. One of
	\texttt{Inside}, \texttt{Proximity}, \texttt{Distant},
\texttt{NotInRange}. The Player is inside the zone when Player.ObjectLocation
is within the perimiter. Otherwise, if the distance to the perimiter is smaller
than ProximityRange, the State is Proximity. If it is larger than
ProximityRange, but smaller than DistanceRange, the State is Distant. Otherwise
it is NotInRange. The Engine may use any method to avoid Players from jumping
in and out of a zone due to GPS jitter.  This means that it is possible that
the value of this attribute does not strictly match with this description.  If
not specified in the constructor, the initial value of State is NotInRange. If
this is not the actual state at that time, callbacks are immediately called as
if the Player has moved from NotInRange to their current location.}%XXX: Enum?

\subsubsection{ZTask (ZObject)}
A task that the player can, and often should, do. There are three possible states: incomplete, done (correctly completed) and failed (complete, but incorrect).
\funcdef{ZTask (Cartridge)}{ZTask}{}{Constructor.}
\attrdef{Complete}{Boolean}{If true, the ZTask is considered completed. The Engine MUST show this to the Player.}
\attrdef{Correct}{Boolean}{If Complete if false, this is ignored. Otherwise, it defines if the task was correctly completed. The Engine MUST show this to the Player.}

\subsubsection{ZTimer (ZObject)}
A timer which can be used to schedule one-time or periodic (interval)
callbacks. For interval timers, the Engine SHOULD call the OnTick
function at constant intervals. However, there is no guarantee that this is
always possible.
\funcdef{ZTimer (Cartridge)}{ZTimer}{}{Constructor.}
\funcdef{ztimer:Start ()}{nil}{}{Starts the timer. If it was already running, do nothing. If ztimer.Remaining is negative, it is set to ztimer.Duration. If ztimer.Remaining is 0, a Tick event is immediately triggered. A Cartridge MUST NOT set Duration of an interval timer to 0.}
\funcdef{ztimer:Stop ()}{nil}{}{Stops the timer. If it was not running, do nothing.}
\funcdef{ztimer:Tick ()}{nil}{}{This function is called when the timer expires. It can be called from the Lua code to fake an expired timer event. Countdown timers are stopped when this is called. Interval timers are restarted.}
\attrdef{Duration}{Number}{Time in seconds. This is used when ztimer is started with a negative Remaining value. In particular, it is used as the restart value for Interval ZTimers.}
\attrdef{OnStart}{Function}{Event which is triggered when Start is called. It is not triggered when an Interval ZTimer restarts.}%XXX This should be removed.
\attrdef{OnStop}{Function}{Event which is triggered when Stop is called. It is not triggered when a ZTimer expires.}%XXX: This should be removed.
\attrdef{OnTick}{Function}{Event which is triggered when the timer expires. For Interval timers, this is called after restarting the timer, so calling Stop from this event will work as expected.}
\attrdef{Remaining}{Number}{Time in seconds before it expires. If the timer is running, this value will automatically count down. This is a read-only value.}
\attrdef{Type}{String}{Must be \texttt{Countdown} or \texttt{Interval}. Defines whether ztimer stops or restarts when it expires.  If not specified, this defaults to Countdown.}%XXX: Change this to a boolean, or an enum?

\subsubsection{ZCommand}
Helper object for commands on ZItems and Zones. When these are displayed, it may
be possible to run commands with them. There are two ways that this is
possible: with a different object, or on its own.

ZCommands work by being included in the Commands attribute of a Zone or ZItem.
The object that includes it is called the Owner. For commands that work with
objects, the object it works with is called the Target.

There are several options, each of which may have a different visualization.
Engines can choose how to do this visualization. The list below only gives
examples.

\begin{enumerate}
	\item Command works on its own. A single button is displayed.
	\item Command works with objects, but no candidates are available. A line of text explaining this is displayed. A candidate object is available if both its Visible and Active attributes are true.
	\item Command works with objects, and one or more objects are available. A group of buttons is displayed; one for each object.
\end{enumerate}

When a command is activated by the Player, a callback is triggered on the Owner
ZObject.

\funcdef{ZCommand (Cartridge)}{ZCommand}{}{Constructor.}
\attrdef{CmdWith}{Boolean}{If true, the command needs an object to work on.}
\attrdef{EmptyTargetListText}{String}{The text that is displayed for commands which need an object, when none is available.}
\attrdef{Enabled}{Boolean}{If set the false, the command cannot be run. The Engine SHOULD NOT show it to the Player at all.}
\attrdef{MakeReciprocal}{Boolean}{Only used if CmdWith is true and WorksWithAll is false. If true (the default), the command SHOULD also be shown when the Target ZObject is shown.}
\attrdef{Text}{String}{The text that is shown to identify the command. For example, \textit{Talk}. This must be a short text. It is often identical to the name used to register the command with an object.}
\attrdef{WorksWithAll}{Boolean}{Only used if CmdWith is true. If this is true, every ZItem, except the Owner object, will automatically be in the list of available targets.}
\attrdef{WorksWithList}{Table of ZObjects}{Only used if CmdWith is true. This is a list of candidate ZItems and Zones for using the command with. If WorksWithAll is true, any ZItems are valid targets regardless of whether they are in this list.}

\subsubsection{ZMedia}
Interface for objects which reference external data: a sound or an image.

The metadata describes which files or URLs are used to get the external media,
including the compiler directives for selecting and modifying it for use on the
target device. All ZMedia objects are created when starting the Cartridge,
before running any Lua code.  Lua code MUST NOT create ZMedia objects itself.

ZMedia are used from Lua code, by linking them to messages (for images) or
using them with PlayAudio (for sounds).
\attrdef{AltText}{String}{Text which the Engine SHOULD display instead of the
image, if it cannot display the image for any reason.}

\subsubsection{ZInput (ZObject)}
Helper object to request input from the Player. There are three types of input:
button, multiple choice and text. A button input will present a message to the
Player and wait for a button to be pressed. A multiple choice input is similar,
but there can be multiple buttons to choose from. A text input requests a line
of text from the Player.

When requesting the input, the Engine is normally using the image in
zinput.Media as an illustration, if there is one.
\funcdef{ZInput (Cartridge)}{ZInput}{}{Constructor.}
\attrdef{OnGetInput}{Function}{Event which is triggered when a multiple choice or text input is answered. It is passed a string argument: the text on the button that was pressed for a multiple choice input; the entered text for a text input. If the input is cancelled, this event is triggered with nil as its argument.}
\attrdef{Text}{String}{Text which is displayed to request the input.}

\subsection{Functions}
\subsubsection{User interface}
These functions may not be called during Boot Time.

There is always at most one graphical function waiting for Player input. If a
second one is called before the previous one was answered, it will replace it.
The previous message's callback function will be called with a nil argument to
signify that this happened.

\funcdef{Alert ()}{nil}{}{Give a signal to the Player, such as a beep or a flash.}
\funcdef{Dialog (table)}{nil}{table: a list of messages.}{Show a list of messages to the player, in sequence. The elements of the Table are the same as the argument of the MessageBox function, except that they cannot have a Callback or Buttons (the Engine provides a way to show the messages, such as an Ok button after each message).}
\funcdef{DriveTo (zonepoint)}{nil}{target ZonePoint}{Leave the Engine interface temporarily, and let the device navigate the Player to zonepoint.  How this is done, if at all, is implementation defined.  There is no callback when the Player has arrived.}
\funcdef{GetInput (zinput)}{nil}{The ZInput to request.}{Request a previously defined input from the Player.}
\funcdef{LogMessage (message)}{nil}{Message to log}{Write a message to a log file. The Engine MAY display the message to the Player as well. The log format is described below.}
\funcdef{MessageBox (table)}{nil}{table: the message to display.}{The Table, like a ZInput, contains a Text to display, and an optional Media containing an image. In addition, it contains Buttons, which is a Table of strings, which SHOULD be printed on buttons, and a Callback function, which MUST be called when an option is selected. Callback is passed a string 'Button1' if the first button is pressed, 'Button2' for the second, etc.}
\funcdef{PlayAudio (sound)}{nil}{The ZMedia to play.}{Play sound (which must be a sound media file). Any previously playing sound MAY be stopped.}
\funcdef{SaveClose ()}{nil}{}{Save the game and quit the Engine.}
\funcdef{ShowScreen (which, [item])}{nil}{which: One of the SCREEN-constants.\\item: a ZObject}{Try to focus the Player's attention on the given part of the interface. If which is DETAILSCREEN, item MUST be used to specify of which object the details should be shown. For other values of which, item MUST be omitted and SHOULD be ignored.}
\funcdef{ShowStatusText (text)}{nil}{message string}{Let the Player know about something in a non-invasive way. Normally, this happens by showing the text in the status bar of the Engine.}
\funcdef{StopSound ()}{nil}{}{Abort all currently playing sounds.}

\subsubsection{Spherical arithmetics}
These functions SHOULD use spherical arithmetics to perform their task. At the very least, they MUST work properly for zones crossing any coordinate boundary.  All distances are in meters; all bearings are in degrees with 0 meaning north and 90 meaning east.  Bearing return values MUST be in the interval from 0 (inclusive) to 360 (exclusive).  Bearing arguments have no such limitation.
\funcdef{IsPointInZone (point, zone)}{Boolean}{point: The ZonePoint to test.\\zone: The Zone te test.}{Return true if point and zone.OriginalPoint are in the same segment of the sphere.}
\funcdef{TranslatePoint (point, distance, bearing)}{ZonePoint}{point: point to translate.\\distance, bearing: vector to translate over.}{Return the ZonePoint where you end up when moving from point over vector.}
\funcdef{VertorToPoint (point1, point2)}{distance, bearing}{point1, point2: ZonePoints}{Return the vector from point1 to point2.}
\funcdef{VectorToSegment (point, s1, s2)}{distance, bearing}{point: the ZonePoint to test.\\s1, s2: the ZonePoint endpoints of the segment to test. The segment is the shortest line over the sphere from s1 to s2. s1 and s2 MUST NOT be exactly opposite each other.}{Determine the closest point on the segment from point; return the vector from point to this point.}
\funcdef{VectorToZone (point, zone)}{distance, bearing}{point: the ZonePoint to test.\\zone: the Zone to test.}{Return the minimum of the results of VectorToSegment for each of the segments of the perimiter of the Zone.}

\subsubsection{Other}
\funcdef{NoCaseEquals (s1, s2)}{Boolean}{s1, s2: strings to compare.}{Return the case-insensitive comparison of s1 and s2.}
\funcdef{ToUserUnits (distance)}{String}{Distance to convert, in meters.}{Return distance in a suitable format for displaying to the user.}

\section{File types}
\subsection{Zipped source: wfz}
A zip archive containing a single directory and nothing more.  The name of this directory is the name of the Cartridge.  The zip archive itself SHOULD be this same name, plus the wfz extension.  This directory contains:

\begin{itemize}
	\item \verb-Cartridge.gwi-: Main cartridge information.  Initial objects are defined here, including ZCartridge and Player.
	\item \verb-Cartridge.lua-: The main script.  This is run at Boot Time.
	\item \verb-Script-: Optional.  A directory containing additional Lua files, if any.
	\item \verb-Media-: Optional.  A directory containing all the media files, if any.
	\item \verb-Translation-: Optional.  A directory containing all the translation files, if any.  Any translations MUST be in gettext format, in the form of countrycode.po, for example \verb-nl_BE.po- for Flemmish (Belgian Dutch).
\end{itemize}

\subsection{Compiled Cartridge: wfc}
%Old format defined at \verb-http://code.google.com/p/wherugo/wiki/GWC-. Additions will be required for supporting the new metadata format.
The gwc format is identical to the gwz format, with the following differences.
\begin{itemize}
	\item \verb-Cartridge.lua- SHOULD be compiled.
	\item \verb-Cartridge.gwi- MUST be adjusted to contain only what the target Engine can support.
	\item Media files which are not used by the target platform SHOULD NOT be included.
	\item All included media files MUST be explicitly defined in \verb-Cartridge.gwi-.
	\item The Translation directory MUST contain mo files instead of po files.
	\item All indented lines, including implicitly indented empty lines, in \verb-Cartridge.gwi- MUST be indented with only a single space.
\end{itemize}

\subsection{Log: gwl}
One line per message, with fields separated by \verb-|-. The fields are:
\begin{enumerate}
	\item Timestamp; 14 digits without separators: Year (4), month (2), day (2), hour (2), minutes (2), seconds (2).
	\item Latitude, in degrees. Positive means north.
	\item Longitude, in degrees. Positive means east.
	\item Altitude in meters.
	\item GPS precision in meters.
	\item Message, which can be any string not containing a newline. Note that it can contain \verb-|-, which MUST NOT be treated as a field separator.
\end{enumerate}

\subsection{Metadata: Cartridge.gwi}
The cartridge and media metadata in the gwi-file is given in RFC822-like form;
the same that is used in e-mail headers. Every field consists of one line,
which cannot be indented.  This line is broken at the first colon (:).  The
part before it is called the key, the part after it is called the value.  Both
the key and the value have any surrounding whitespace stripped off.

For clarity, an example Cartridge follows below.

The unindented line with the key and value is sometimes followed by one or more
indented lines. These lines together, including the newlines, but excluding the
indentation, are called the Long Value. Empty lines are considered indented
empty lines, even if they don't have any indentation.  Such lines (with or
without indentation) are ignored outside of a long value.  They are stripped
from the end of a long value, but preserved inside it.

Any keys for which this document does not define a long value MUST NOT have one.

Lines starting with a (possibly indented) \texttt{\#} are comments and ignored
completely, no matter where they are.  A \texttt{\#} can be part of a value.

The data consists of a format definition, followed by a series of blocks.  Each
block starts with an object definition, with the object type as its key.  All
following keys define properties of that object, until the next object
definition starts.  All these properties MUST be defined ont he created Lua
object by the Engine.  For boolean attributes, the value MUST be either
\texttt{true} or \texttt{false}, ignoring case, and the Engine MUST set the
attribute to the boolean, not the string.  For numerical attributes, the Engine
MUST set the attribute to the number.  ZonePoints are given as a list of three
numbers, separated by spaces.  The first number is the latitude, in degrees,
the seconds is the longitude in degrees and the third is the altitude in
meters.  If the value is the string \texttt{none}, it will be set to
\verb-INVALID_ZONEPOINT-.

The value of the object definition is the identifier of the object.
The identifier MUST consist of one or more groups of identifier parts
separated by periods.  Every identifier part must only contain unaccented uppercase
and lowercase roman letters, digits and underscores, and must not start with a
digit.  In regular expression terms, an identifier part is
\verb#[A-Za-z_][A-Za-z0-9_]*# and the full object identifier is
\verb#[A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*)*#.

When the Engine creates the objects, it MUST add a variable to the Lua
environment.  Objects which have an identifier consisting of a single part MUST
be created in the global namespace.  For objects with two parts, if an object
with the first part as its identifier exists, it must be created as an
attribute of that object.  If not, a table must be created and the object must
be added to this table.  For objects with more parts, the same rule is
recursively applied.

The format definition is a single line, which uses the word Format as a key.
Its value MUST be set to the exact string \texttt{1.0}.

\newcommand\defkey[5]{\par\noindent\begin{tabular}{|l|l|}\hline Key&#1\\Value&\parbox{.75\textwidth}{#2}\\Long Value&\parbox{.75\textwidth}{#3}\\Comments&\parbox{.75\textwidth}{#4}\\\hline\end{tabular}\par}

\subsubsection{Common attributes}
Some attributes are valid for all objects.  These are: \textit{Active},
\textit{Icon}, \textit{Media}, \textit{Name} and \textit{Visible}.  The Icon
and Media keys, if defined, SHOULD have the identifier of a MediaSource as
their value.  See also the discussion of MediaSource below.

\subsubsection{ZCartridge}
This defines the global settings of the Cartridge.  The following keys are allowed: \textit{Activity}, \textit{Author}, \textit{BuilderVersion}, \textit{Company}, \textit{Copyright}, \textit{CreateDate}, \textit{CountryId}, \textit{Email}, \textit{Id}, \textit{License}, \textit{PublishDate}, \textit{StartingLocation}, \textit{StateId}, \textit{TargetDevice}, \textit{TargetDeviceVersion}, \textit{UseLogging}, \textit{UpdateDate} and \textit{Version}.

Of these, StartingLocation, License and Copyright can have a long value, which will be used as StartingLocationDescription, LicenseText and Copyrights respectively.  License SHOULD use the value for the name or abbreviation of the license, and the long value for any explanation, or the license text itself.

\subsubsection{ZTimer}
Possible keys: \textit{Type} and \textit{Duration}.  Type defaults to \texttt{Countdown}, Duration to -1 (which makes the timer unusable until it is set to a positive value).

\subsubsection{ZInput}
Possible keys: \textit{Text} and \textit{InputType}.  InputType defaults to \texttt{Text}.

\subsubsection{ZItem}
Possible keys: \textit{Container} and \textit{ObjectLocation}.  The Container must be the name of a ZItem or Zone as defined in Cartridge.wfi.  Objects may be defined in any order; the Engine MUST allow forward references as well as back references.  Objects MUST NOT contain themselves (directly or through other container objects).

\subsubsection{ZTask}
Possible keys: \textit{Complete} and \textit{CorrectState}.  Complete defaults to false, CorrectState to true.

\subsubsection{Zone}
Possible keys: \textit{ShowObjects}, \textit{State}, \textit{ProximityRange}, \textit{DistanceRange}, \textit{Points}.  ShowObjects defaults to OnEnter, State defaults to NotInRange, ProximityRange and DistanceRange both default to -1.  The value and long value of Points are merged into one.  The short value MAY be empty.  There MUST NOT be empty lines in the long value.  Every line is parsed as a ZonePoint.  The resulting Table is assigned to the attribute.

\subsubsection{ZMedia}
Possible keys: \textit{File} and \textit{URL}.  Both attributes may be specified any number of times.  Every attribute declares that the value can be used to provide the media (either from the Cartridge, or from the internet).

In addition to the objects defined in Cartridge.wfi, the Engine MUST create
ZMedia objects for any file in a subdirectory of Media that is not referenced
by any ZMedia object definition.  If they are in a subdirectory of Media, the
ZMedia object must be created as if the name is the path relative to Media,
with the period as directory separator.  The object identifier and the Name
attribute of such implicitly defined ZMedia objects MUST be set to this
filename with directory separators replaced by periods, excluding the
extension.  If a ZMedia with that object identifier already exists, the file
MUST be treated as if it was referenced as a File attribute for that object.
The Cartridge MUST NOT define objects other than ZMedia with object identifiers
of implicitly defined ZMedia.

If a media object is defined and no sources are present, it MUST be treated the
same way as if there are sources, but none of them can be used. This is not an
error: for images, the Alt text SHOULD be displayed instead of the image; for
sounds, requests to play them SHOULD play an Engine-defined default sound.

\subsubsection{Command}
This is a special type of object.  It must directly follow a Zone or ZItem object, or another Command object.  The command is added to the Zone or ZItem that it follows, in its Commands attribute.  The following keys are allowed for Command: \textit{Text}, \textit{CmdWith}, \textit{WorksWithAll}, \textit{WorksWithList} and \textit{EmptyTargetListText}.  The value of WorksWithList is a space separated list of object identifiers.

\subsection{Example cartridge}
\subsubsection{Lua file}
\noindent\begin{lstlisting}
require "Wherigo"

function cartridge:OnStart ()
	Wherigo.PlayAudio (bell)
	Wherigo.Dialog {{Text = "Look at me!",
		Media = Image.dude},}
end

return cartridge
\end{lstlisting}
\subsubsection{gwi file}
\noindent\begin{lstlisting}
Format: 1.0
ZCartridge: cartridge
Name: Example Cartridge
	This is an example cartridge header,
	showing how it is built up.
	This description can be shown when
	selecting which cartridge to play.
Version: 1.0
Author: Bas Wijnen
E-mail: <wijnen@debian.org>
Copyright: Copyright 2013 Bas Wijnen
License: AGPL-3+
	You may copy, modify and redistribute
	this cartridge under the terms of the
	GNU Affero General Public License,
	version 3 or later (at your option).
	See http://www.gnu.org/licenses/agpl-3.0.html
	for details.
Activity: TourGuide
StartingLocation: 53.0 6.0 0
	Go there and see farmland!
\end{lstlisting}

In the file, Media/bell.wav and Media/Image/dude.jpg are also packaged. They do
not need to be mentioned in the gwi-file.

\subsection{Saved game: ?}
The format for this file still has to be decided, if it is going to be
standardized at all.
\end{document}
