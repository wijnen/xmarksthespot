#!/usr/bin/env python

'''
Wherigo cartridge player.

Game screens:
- map with location, visible items, characters and zones. can be zoomed and panned.
- compass with target arrow(s)
- inventory
- item detail (possibly on same screen as inventory)
- task list
- task detail (possibly on same screen as task list)
- dialogs and messages: both multiple simultaneously.
'''

debug = False

# Color definitions.
# Stuff on the map.
zonescolor = '#00f'	# also in a tab.
characterscolor = '#f00'
objectscolor =  '#880'
positioncolor = '#000'
gridcolor = '#ccc'

# Stuff in the tabs.
environmentcolor = '#f00'
inventorycolor = '#880'
taskcolor = '#000'
messagecolor = '#000'
historycolor = '#ccc'
timercolor = '#f0f'

import lua
import re
import gps
import gtk
import gwc
import sys
import time
import wherigo
import Map
import gst
import args

a = args.ArgumentParser ()
a.add_argument ('cartridge', help = 'The cartridge to load', type = open)
gwcfile = a.parse_args ().cartridge

def backtrace ():
	sys.stderr.write ('=' * 78 + '\n')
	try:
		d = 0
		while True:
			frame = sys._getframe (d)
			sys.stderr.write ('\t%s:%d %s\n' % (frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name))
			d += 1
	except ValueError:
		pass
	sys.stderr.write ('=' * 78 + '\n')

minloglevel = wherigo.LOGDEBUG

class Position:
	def __init__ (self, lat = None, lon = None, alt = None, speed = None, climb = None, track = None, time = None):
		self.lat = lat
		self.lon = lon
		self.alt = alt
		self.speed = speed
		self.climb = climb
		self.track = track
		self.time = time
	def __nonzero__ (self):
		return self.time != None
	def __str__ (self):
		if self.time == None:
			return 'None'
		return 'lat:%f lon:%f alt:%f speed:%f climb:%f track:%f time:%s' % (self.lat, self.lon, self.alt, self.speed, self.climb, self.track, self.time)

class GpsPoller:
	def __init__(self):
		self.current_value = Position ()
		self.idle = [10, None]
		self.session = gps.gps (mode = gps.WATCH_ENABLE)
	def get_pos (self):
		while self.session.waiting ():
			value = self.session.next ()
			# Save only position, not every event.
			if value['class'] == 'DEVICE' and value['activated'] == 0:
				self.current_value = Position ()
				continue
			if value['class'] != 'TPV':
				continue
			if value['mode'] == 1:
				self.current_value = Position ()
			else:
				self.current_value = Position (value['lat'], value['lon'], value['alt'], value['speed'], value['climb'], value['track'], value['time'])
		#print self.current_value
		ret = self.current_value
		if self.idle[1] == ret.time:
			if self.idle[0] == 10:
				self.idle = [10, None]
				ret = Position ()
				self.current_value = ret
			else:
				self.idle[0] += 1
		else:
			self.idle = [0, ret.time]
		return ret

class Detail (gtk.VBox):
	def __init__ (self):
		gtk.VBox.__init__ (self)
		self.image = gtk.Image ()
		self.pack_start (self.image, False)
		self.text = gtk.TextView ()
		self.text.set_can_focus (False)
		self.text.set_wrap_mode (gtk.WRAP_WORD)
		self.text.set_editable (False)
		sw = gtk.ScrolledWindow ()
		sw.add (self.text)
		self.pack_start (sw, True)
		self.buttons = gtk.HBox ()
		self.pack_start (self.buttons, False)
	def set (self, media, text, buttons, cb):
		if media:
			if media.Id in gameobject._image:
				self.image.set_from_pixbuf (gameobject._image[media.Id])
		else:
			self.image.clear ()
		self.text.get_buffer ().set_text (re.sub ('\s*<br>\s*', '\n', re.sub ('\s+', ' ', text.replace ('&amp;', '&').replace ('&nbsp;', ' '), 0, re.DOTALL), 0, re.IGNORECASE | re.DOTALL))
		self.remove (self.buttons)
		self.buttons = gtk.HBox ()
		self.pack_start (self.buttons, False)
		should_fill = True
		for b in buttons:
			if b[1] is None:
				# This is a text entry.
				entry = gtk.Entry ()
				self.buttons.pack_start (entry, True)
				if cb is not None:
					entry.connect ('activate', cb, b[0])
					entry.grab_focus ()
				should_fill = False
			else:
				# This is a button.
				button = gtk.Button (b[1])
				if cb is not None:
					button.connect ('clicked', cb, b[0])
				button.set_can_focus (False)
				self.buttons.pack_start (button, should_fill)
		self.buttons.show_all ()

class List (gtk.VBox):
	def __init__ (self, title):
		gtk.VBox.__init__ (self)
		self.store = gtk.ListStore (str, str, object, bool, bool)
		self.treeview = gtk.TreeView (self.store)
		self.treeview.set_can_focus (False)
		if debug:
			self.activecolumn = gtk.TreeViewColumn ('active')
			self.visiblecolumn = gtk.TreeViewColumn ('visible')
			self.treeview.append_column (self.activecolumn)
			self.treeview.append_column (self.visiblecolumn)
			self.activerenderer = gtk.CellRendererToggle ()
			self.visiblerenderer = gtk.CellRendererToggle ()
			self.activecolumn.pack_start (self.activerenderer, True)
			self.visiblecolumn.pack_start (self.visiblerenderer, True)
			self.activecolumn.add_attribute (self.activerenderer, 'active', 3)
			self.visiblecolumn.add_attribute (self.visiblerenderer, 'active', 4)
		self.column = gtk.TreeViewColumn (title)
		self.treeview.append_column (self.column)
		self.renderer = gtk.CellRendererText ()
		self.column.pack_start (self.renderer, True)
		self.column.add_attribute (self.renderer, 'text', 0)
		self.column.add_attribute (self.renderer, 'foreground', 1)
		self.treeview.set_reorderable (True)
		self.treeview.get_selection ().connect ('changed', self.selection_changed)
		self.pack_start (self.treeview, False)
		self.pack_start (gtk.HSeparator (), False)
		self.details = Detail ()
		self.pack_start (self.details, True)
	def _find (self, model, path, iter, data):
		if model.get_value (iter, 0) == data[0]:
			data[1] = iter
			return True
	def select (self, item):
		data = [item, None]
		self.store.foreach (self._find, data)
		if data[1] == None:
			return
		self.treeview.get_selection ().select_iter (data[1])
	def selection_changed (self, selection):
		# Update details according to new selection.
		i = selection.get_selected ()[1]
		if i:
			item = self.store.get_value (i, 2)
			media = item.Media
			text = item.Description
			buttons = []
			for c in item.Commands:
				cmd = item.Commands[c]
				if not cmd.Enabled:
					continue
				t = cmd.Text
				if cmd.CmdWith:
					if cmd.WorksWithAll:
						for i in gameobject.AllZObjects:
							if (isinstance (i, wherigo.ZCharacter) or isinstance (i, wherigo.ZItem)) and i.Visible:
								break
						else:
							t = cmd.EmptyTargetListText
					else:
						for i in cmd.WorksWithList:
							target = cmd.WorksWithList[i]
							if target.Visible:
								break
						else:
							t = cmd.EmptyTargetListText
				buttons += (((c, item), t),)
		else:
			item = None
			media = None
			text = ''
			buttons = []
		self.details.set (media, text, buttons, self._button)
		# Update markers on map, if any.
		self._update_map (item)
	def _button (self, widget, name):
		attr = 'On' + name[0]
		if hasattr (name[1], attr):
			getattr (name[1], attr) (name[1])
		else:
			print ('Command "%s" not running, because no callback was registered.' % name[0])
		return True
	def _update_map (self, item):
		# Overloaded from Lists which need it.
		pass
	def update (self):
		keys, full = self.makelist ()
		# Step 1: remove all items that should not be present.
		current = self.store.get_iter_first ()
		while current:
			next = self.store.iter_next (current)
			k = self.store.get_value (current, 0)
			if k not in keys:
				self._remove_item (current)
			else:
				i = keys.index (k)
				keys.pop (i)
				full.pop (i)
			current = next
		# Step 2: add all missing items
		for f in full:
			self._add (*f)
		# Step 3: update the information
		if debug:
			current = self.store.get_iter_first ()
			while current:
				i = self.store.get_value (current, 2)
				self.store.set_value (current, 3, i.Active != 0)
				self.store.set_value (current, 4, i.Visible != 0)
				self._debug_update_map (i)
				current = self.store.iter_next (current)
		map.update ()
	def _add (self, summary, color, info, active, visible):
		# Overload this to do more.
		self.store.append ((summary, color, info, active, visible))
	def _remove_item (self, item):
		self.store.remove (item)
	def _debug_update_map (self, i):
		pass

class MarkerList (List):
	'''A list with links to markers on the map'''
	def __init__ (self, map, desc, layers):
		List.__init__ (self, desc)
		self.map = map
		self.layers = layers
		self.selected = None
	def _add (self, summary, color, info, active, visible):
		self.store.append ((summary, color, info, active, visible))
		pos = self._get_pos (info)
		if not pos:
			info._id = None
			print ('not adding %s to map: no position' % summary)
			return
		layer = self._get_layer (info)
		info._id = len (self.layers[layer].markers)
		self.layers[layer].markers += ([(pos.latitude, pos.longitude), [False, active and visible], info],)
		self.map.update ()
	def _get_pos (self, info):
		# Overloadable.
		return info.ObjectLocation
	def _get_layer (self, info):
		# Overloadable for multi-layer lists.
		return 0
	def _update_map (self, item):
		if self.selected is not None and self.selected._id is not None:
			layer = self._get_layer (self.selected)
			self.layers[layer].markers[self.selected._id][1][0] = False
		if item is not None and item._id is not None:
			layer = self._get_layer (item)
			self.layers[layer].markers[item._id][1][0] = True
		self.selected = item
		self.map.update ()
	def _debug_update_map (self, item):
		'Update active and visible status on map'
		layer = self._get_layer (item)
		self.layers[layer].markers[item._id][1][1] = item.Active and item.Visible
	def _remove_item (self, item):
		i = self.store.get_value (item, 2)
		List._remove_item (self, item)
		layer = self._get_layer (i)
		del self.layers[layer].markers[i._id]
		for check in self.layers[layer].markers:
			if check[2]._id >= i._id:
				check[2]._id -= 1

class Locations (MarkerList):
	# Compass and list of locations; selected location is shown on compass.
	def __init__ (self, layer):
		MarkerList.__init__ (self, layer.map, 'Location', (layer,))
	def _get_pos (self, info):
		return info.OriginalPoint
	def add_location (self, summary, info):
		self._add (summary, info, info.Active, info.Visible)
	def makelist (self):
		kret = []
		fret = []
		for i in gameobject.AllZObjects:
			if isinstance (i, wherigo.Zone) and (debug or (i.Active and i.Visible)):
				kret += (i.Name,)
				fret += ((i.Name, zonescolor, i, i.Active, i.Visible),)
		return kret, fret
	def _update_map (self, item):
		# Add zone boundary for selected zone.
		if item is None or item._id is None:
			self.layers[0].tracks = []
		else:
			track = [(x.latitude, x.longitude) for x in lua.as_list (item.Points)]
			track += (track[0],)
			self.layers[0].tracks = [track]
		# Do all the usual stuff.
		MarkerList._update_map (self, item)

class Inventory (List):
	def __init__ (self):
		List.__init__ (self, 'Item')
	def add_item (self, name, info):
		self.store.append ((name, info))
	def makelist (self):
		kret = []
		fret = []
		for i in gameobject.AllZObjects:
			if isinstance (i, wherigo.ZItem) and (debug or (i.Active and i.Visible)) and i.Container == wherigo.Player:
				kret += (i.Name,)
				fret += ((i.Name, inventorycolor, i, i.Active, i.Visible),)
		return kret, fret

class Environment (MarkerList):
	def __init__ (self, objlayer, charlayer):
		MarkerList.__init__ (self, objlayer.map, 'Item or person', (objlayer, charlayer))
	def add_item (self, name, info):
		self._add (name, info, info.Active, info.Visible)
	def add_person (self, name, info):
		self._add (name, info, info.Active, info.Visible)
	def _get_layer (self, info):
		return 1 if isinstance (info, wherigo.ZCharacter) else 0
	def makelist (self):
		kret = []
		fret = []
		for i in gameobject.AllZObjects:
			if ((isinstance (i, wherigo.ZItem) and i.Container != wherigo.Player) or isinstance (i, wherigo.ZCharacter)) and (debug or (i.Active and i.Visible)):
				kret += (i.Name,)
				fret += ((i.Name, characterscolor if isinstance (i, wherigo.ZCharacter) else objectscolor, i, i.Active, i.Visible),)
		return kret, fret

class Tasks (List):
	def __init__ (self):
		List.__init__ (self, 'Task')
	def add_task (self, summary, info):
		self.store.append ((summary, info))
	def makelist (self):
		kret = []
		fret = []
		for i in gameobject.AllZObjects:
			if isinstance (i, wherigo.ZTask) and (debug or (i.Active and i.Visible)):
				kret += (i.Name,)
				fret += ((i.Name, taskcolor, i, i.Active, i.Visible),)
		return kret, fret

class History (gtk.VBox):
	def __init__ (self):
		gtk.VBox.__init__ (self)
		self.store = gtk.ListStore (str, object)
		self.selector = gtk.ComboBox (self.store)
		cell = gtk.CellRendererText ()
		self.selector.pack_start (cell)
		self.selector.add_attribute (cell, 'text', 0)
		self.pack_start (self.selector, False)
		self.detail = Detail ()
		self.pack_start (self.detail, True)
		self.selector.connect ('changed', self.update)
	def add_item (self, media, text, buttons):
		title = time.strftime ('%X')
		self.store.append ((title, (media, text, buttons, None)))
	def update (self, widget):
		i = self.selector.get_active_iter ()
		if i is None:
			self.detail.set (None, '', (), None)
		else:
			item = self.store.get_value (i, 1)
			self.detail.set (*item)

class Timers (gtk.TreeView):
	def __init__ (self):
		signature = (str, str, bool, str, str, str, object)
		self.store = gtk.ListStore (*signature)
		gtk.TreeView.__init__ (self, self.store)
		self.set_can_focus (False)
		self.columns = [gtk.TreeViewColumn (x) for x in ('Name', 'Type', 'Running', 'Remaining', 'Duration')]
		self.renderer = [gtk.CellRendererToggle () if signature[c] == bool else gtk.CellRendererText () for c in range (len (self.columns))]
		for c in range (len (self.columns)):
			self.append_column (self.columns[c])
			self.columns[c].pack_start (self.renderer[c], True)
			self.columns[c].add_attribute (self.renderer[c], 'active' if signature[c] is bool else 'text', c)
			if signature[c] is not bool:
				self.columns[c].add_attribute (self.renderer[c], 'foreground', 5)
		self.set_reorderable (True)
	def add_timer (self, name):
		self.store.append ((name, 'Countdown', False, '', ''))
	def mktime (self, t):
		return '%5.2f' % t
	def update (self):
		keys = []
		full = []
		for i in gameobject.AllZObjects:
			if isinstance (i, wherigo.ZTimer):
				keys += (i.Name,)
				full += ((i.Name, '', False, '', '', timercolor, i),) # Actual values are filled in below, in step 3.
		# Step 1: remove all items that should not be present.
		current = self.store.get_iter_first ()
		while current:
			next = self.store.iter_next (current)
			k = self.store.get_value (current, 0)
			if k not in keys:
				self._remove_item (current)
			else:
				i = keys.index (k)
				keys.pop (i)
				full.pop (i)
			current = next
		# Step 2: add all missing items
		for f in full:
			self.store.append (f)
		# Step 3: update contents.
		current = self.store.get_iter_first ()
		while current:
			i = self.store.get_value (current, 6)
			self.store.set_value (current, 1, i.Type)
			self.store.set_value (current, 2, i._target is not None)
			self.store.set_value (current, 3, int (i.Remaining))
			self.store.set_value (current, 4, '%6.3f' % i.Duration)
			current = self.store.iter_next (current)

class CB:
	pipeline = None
	def dialog (self, table):
		global queue
		self.update ()
		queue_reset ()
		for m in lua.as_list (table):
			queue += (m,)
		next_message ()
		self.update ()
	def message (self, table):
		global queue
		self.update ()
		queue_reset ()
		queue += (table,)
		next_message ()
		self.update ()
	def get_input (self, zinput):
		global queue
		self.update ()
		queue_reset ()
		queue += (zinput,)
		next_message ()
		self.update ()
	def play (self, media):
		self.stop_sound ()	# includes update.
		if media.Id not in gameobject._sound:
			return
		self.pipeline = gst.Pipeline ("pipeline")
		source = gst.element_factory_make ("appsrc", "source")
		self.pipeline.add (source)
		decoder = gst.element_factory_make ("decodebin", "decoder")
		self.pipeline.add (decoder)
		converter = gst.element_factory_make ("audioconvert", "converter")
		self.pipeline.add (converter)
		sink = gst.element_factory_make ("alsasink", "sink")
		self.pipeline.add (sink)
		source.link (decoder)
		decoder.link (converter)
		converter.link (sink)
		source.emit ('push-buffer', gameobject._sound[media.Id])
		self.pipeline.set_state (gst.STATE_PLAYING)
	def stop_sound (self):
		self.update ()
		if self.pipeline:
			self.pipeline.set_state (gst.STATE_READY)
			self.pipeline = None
	def set_status (self, text):
		self.update ()
		statusbar.pop (statuscontext)
		statusbar.push (statuscontext, text)
	def save (self):
		if gameobject.OnSync:
			gameobject.OnSync ()
		self.update ()
		# TODO
	def quit (self):
		self.update ()
		print ('request to quit')
		#gtk.main_quit ()
	def drive_to (self, *a):
		self.update ()
		print ("I'm supposed to drive to", a)
		# which is?
		# TODO
	def alert (self):
		self.update ()
		print 'alert!'
		gtk.gdk.display_get_default ().beep ()
	def log (self, level, levelname, text):
		self.update ()
		if level >= minloglevel:
			print 'Log %s: %s' % (levelname, text)
	def show (self, screen, item):
		# 'Detail', 'Inventory', 'Item', 'Location', 'Main', 'Tasks'
		self.update ()
		if screen == wherigo.DETAILSCREEN:
			if isinstance (item, wherigo.ZCharacter):
				notebook.set_current_page (notebook.page_num (environmentscreen))
				environmentscreen.select (item)
			if isinstance (item, wherigo.Zone):
				notebook.set_current_page (notebook.page_num (locationscreen))
				locationscreen.select (item)
			if isinstance (item, wherigo.ZItem):
				if item.Container == wherigo.Player:
					notebook.set_current_page (notebook.page_num (inventoryscreen))
					inventoryscreen.select (item)
				else:
					notebook.set_current_page (notebook.page_num (environmentscreen))
					environmentscreen.select (item)
			if isinstance (item, wherigo.ZTask):
				notebook.set_current_page (notebook.page_num (taskscreen))
				taskscreen.select (item)
		elif screen == wherigo.INVENTORYSCREEN:
			notebook.set_current_page (notebook.page_num (inventoryscreen))
		elif screen == wherigo.ITEMSCREEN:
			notebook.set_current_page (notebook.page_num (environmentscreen))
		elif screen == wherigo.LOCATIONSCREEN:
			notebook.set_current_page (notebook.page_num (locationscreen))
		elif screen == wherigo.MAINSCREEN:
			notebook.set_current_page (notebook.page_num (locationscreen))
		elif screen == wherigo.TASKSCREEN:
			notebook.set_current_page (notebook.page_num (taskscreen))
	def update (self):
		locationscreen.update ()
		inventoryscreen.update ()
		environmentscreen.update ()
		taskscreen.update ()
		if debug:
			timers.update ()

def next_message (widget = None, name = None):
	global queue, current_msg, last_screen
	if current_msg is not None:
		# Fire event for previous message
		attr = 'On' + (current_msg[0] if current_msg[0] is not None else name[0])
		arg = (name[1] if name is not None else widget.get_text () if widget else None)
		if hasattr (current_msg[1], attr):
			getattr (current_msg[1], attr) (current_msg[1], arg)
		current_msg = None
	if len (queue) == 0:
		notebook.set_current_page (last_screen)
		message.hide ()
		return
	info = queue.pop (0)
	if isinstance (info, wherigo.ZInput):
		if 'Media' in dir (info):
			media = info.Media
		else:
			media = None
		text = info.Text
		if info.InputType == 'MultipleChoice':
			buttons = [(x, x) for x in lua.as_list (info.Choices)]
		elif info.InputType == 'Text':
			buttons = [(None, None)]
		else:
			raise AssertionError ('unknown input type')
		current_msg = ('GetInput', info)
	else:
		if 'Media' in info:
			media = info['Media']
		else:
			media = None
		text = info['Text']
		if 'Buttons' in info:
			buttons = [(x, x) for x in lua.as_list (info['Buttons'])]
		else:
			buttons = [('Ok', 'Ok')]
		current_msg = ('Click', info)
	message.set (media, text, buttons, next_message)
	history.add_item (media, text, buttons)
	message.show ()
	p = notebook.get_current_page ()
	if p != notebook.page_num (message):
		last_screen = p
	notebook.set_current_page (notebook.page_num (message))

def queue_reset ():
	global queue
	if len (queue) == 0:
		return
	queue = []
	message.hide ()

queue = []
current_msg = None
#gwcfile = '/home/shevek/src/git/wherpygo/wdyg_scharlakenbos.gwc'
game = gwc.cartridge (gwcfile)
map = Map.Map (game.latitude, game.longitude)	# degrees
map.set_zoom (100000)	# pixels per degree. 1 degree is about 100 km.
map.add_layer (Map.MapLayer (map))
map.add_layer (Map.GridLayer (map, gridcolor))
zones = Map.MarkerLayer (map, zonescolor)
map.add_layer (zones)
objects = Map.MarkerLayer (map, objectscolor)
map.add_layer (objects)
characters = Map.MarkerLayer (map, characterscolor)
map.add_layer (characters)
position = Map.PositionLayer (map, positioncolor)
map.add_layer (position)

win = gtk.Window ()
win.connect ('destroy', gtk.main_quit)
vbox = gtk.VBox ()
win.add (vbox)
box = gtk.HPaned ()
if debug:
	tpaned = gtk.VPaned ()
	timers = Timers ()
	tpaned.add1 (timers)
	tpaned.add2 (box)
	vbox.pack_start (tpaned)
else:
	vbox.pack_start (box)
statusbar = gtk.Statusbar ()
vbox.pack_start (statusbar, False)
statuscontext = statusbar.get_context_id ('status')
statusbar.push (statuscontext, '')
notebook = gtk.Notebook ()
notebook.set_show_tabs (True)
notebook.set_can_focus (False)
box.add1 (notebook)
box.add2 (map)

def add_screen (screen, label, color):
	ret = screen
	l = gtk.Label ('<span foreground="%s">%s</span>' % (color, label))
	l.set_use_markup (True)
	notebook.append_page (ret, l)
	return ret

locationscreen = add_screen (Locations (zones), 'Locations', zonescolor)
inventoryscreen = add_screen (Inventory (), 'Inventory', inventorycolor)
environmentscreen = add_screen (Environment (objects, characters), 'Environment', environmentcolor)
taskscreen = add_screen (Tasks (), 'Tasks', taskcolor)
history = add_screen (History (), 'History', historycolor)
message = add_screen (Detail (), 'Message', messagecolor)
win.show_all ()
map.grab_focus ()
last_screen = notebook.page_num (taskscreen)
if not debug:
	locationscreen.hide ()
	inventoryscreen.hide ()
	environmentscreen.hide ()
	taskscreen.hide ()
	history.hide ()
	# Only the message tab is still available.
notebook.set_current_page (notebook.page_num (message))

device = GpsPoller ()
def update ():
	# Update Timers. Do this before everything else, so Remaining is set correctly during callbacks.
	now = time.time ()
	for i in gameobject.AllZObjects:
		if isinstance (i, wherigo.ZTimer) and i._target != None:
			i.Remaining = i._target - now
	p = device.get_pos ()
	fp = map.get_force_position ()
	update_all = debug
	if fp is not None:
		p = Position (fp[0], fp[1], 0, 0, 0, 0, 0)
	if p:
		position.markers = [[(p.lat, p.lon), [False, True]]]
		wherigo.Player.ObjectLocation = wherigo.ZonePoint (p.lat, p.lon, p.alt)
		for i in gameobject.AllZObjects:
			# Update all object distances and bearings.
			if (isinstance (i, wherigo.ZItem) and i.Container is not wherigo.Player) or isinstance (i, wherigo.ZCharacter):
				if not i.Active:
					continue
				i.CurrentDistance, i.CurrentBearing = wherigo.VectorToPoint (wherigo.Player.ObjectLocation, i.ObjectLocation)
			# Update container info, and call OnEnter or OnExit.
			elif isinstance (i, wherigo.Zone):
				if i._active != i.Active:
					# TODO: Doing this here means that OnSetActive fires after the lua callback has returned. Setting a zone active and immediately inactive doesn't make it fire, while it should make it fire twice.
					i._active = i.Active
					if hasattr (i, 'OnSetActive'):
						i.OnSetActive (i)
						update_all = True
				if not i.Active:
					continue
				inside = wherigo.IsPointInZone (wherigo.Player.ObjectLocation, i)
				if inside != i._inside:
					i._inside = inside
					if inside and hasattr (i, 'OnEnter'):
						i.OnEnter (i)
						update_all = True
					elif not inside and hasattr (i, 'OnExit'):
						i.OnExit (i)
						update_all = True
				if inside:
					i.State = 'Inside'
				else:
					# See how close we are.
					i.CurrentDistance, i.CurrentBearing = wherigo.VectorToZone (wherigo.Player.ObjectLocation, i)
					if i.CurrentDistance < i.ProximityRange:
						i.State = 'Proximity'
					elif i.DistanceRange == -1 or i.CurrentDistance < i.DistanceRange:
						i.State = 'Distant'
					else:
						i.State = 'NotInRange'
					if i.State != i._state:
						i._state = i.State
						attr = 'On' + i.State
						if hasattr (i, attr):
							getattr (i, attr) (i)
							update_all = True
	else:
		position.markers[0][1][1] = False
	if update_all:
		cbs.update ()
	map.update ()
	return True
gtk.timeout_add (500, update)

script = lua.lua ()
script.module ('Wherigo', wherigo)
script.run ('', 'Env', {
	'Platform': 'Python',
	'CartFolder': '/whatever',
	'SyncFolder': '/whatever',
	'PathSep': '/',
	'DeviceID': 'python-id',
	'Version': '2.11-compatible',
	'CartFilename': gwcfile,
	'LogFolder': '/whatever',
	'Downloaded': 0,
	'Device': game.device})
cartridge = wherigo.ZCartridge ()
cbs = CB ()
gameobject = cartridge._setup (game, cbs, script)

def start_game (widget = None, name = None):
	locationscreen.show ()
	inventoryscreen.show ()
	environmentscreen.show ()
	taskscreen.show ()
	history.show ()
	notebook.set_current_page (last_screen)
	message.hide ()
	if gameobject.OnStart:
		gameobject.OnStart ()
		cbs.update ()
text = 'You are about to play "%s":<br><br>' % gameobject.Name + gameobject.Description + '<br><br>Please go to the starting point and press ok.<br>The starting point for this cartridge is defined as follows:<br><br>' + gameobject.StartingLocationDescription
buttons = (('Ok', 'Ok'),)
history.add_item (gameobject.Media, text, buttons)
message.set (gameobject.Media, text, buttons, start_game)
cbs.update ()
gtk.main ()
